
v.to.rast RHONE_PDS out=RHONE_PDS use=val type=area

### DEMs

# resample to 200
g.region -adp res=200
r.resamp.interp in=aster out=aster_200m method=bicubic
r.mapcalc exp='aster_diff_DHM200=aster_200m-DHM200res'
g.region -dp

# replace where +/-50m deviation from DHM
r.mapcalc exp='aster_wrong=if((aster_200m-DHM200res)^2>50^2,1,null())'
r.mapcalc exp='aster_holes=if(isnull(aster_wrong),aster,null())'
# interpolate holes
r.fillnulls input=aster_holes output=aster_iclean method=rst npmin=300 segmax=200


### GLACIERS
g.mapset glaciers

# make rasters
for d in glims_UOslo_1998 glims_UBern_2009
do
    v.to.rast $d type=area out=${d}_rock use=val \
                where="line_type='intrnl_rock'" --o
    v.to.rast $d type=area out=$d use=val
    r.mapcalc exp="$d = if(isnull(${d}_rock), $d, null())" --o
done


# get tongues and distance from sides on the tongues
r.mapcalc exp='tongues=if(!isnull(glims_UOslo_1998@glaciers) & aster_iclean@DEM<2650,null(),1)'
r.grow.distance input=tongues distance=tongues_dist


# glacier elevation distributions
python gla_dist.py


### glacier units
cd ~/wortmann/Methods/glaciers
minelev=1500
minarea=100000

# make slope and aspect raster
r.slope.aspect elevation=aster_iclean@DEM slope=slope_dg aspect=aspect precision=CELL

# mask entire catchment
r.mask catchments@subbasins

# potential glacier area
r.mapcalc exp="glacierarea=if(aster_iclean@DEM> $minelev,1,null())"
# clean small bits
python glaciers.py cleanRast glacierarea garea $minarea 0

r.mask garea --o

# distinguish valleys and slopes (with smoothing)
python glaciers.py valley slope_dg valleys_smooth 19 200
# clean
python glaciers.py cleanRast valleys_smooth valleys $minarea

# make contours (also writes slope and valleys)
python glaciers.py classedContours aster_iclean@DEM valleys contours_classed 30 200
# clean
python glaciers.py cleanRast contours_classed contours_clean $minarea

# make aspect classes (only on slopes)
python glaciers.py aspect aster_iclean@DEM aspect_classed 4
# only take those not in valleys and rest null
r.mapcalc exp='aspect_slopes=int(if(!valleys,aspect_classed,0))'
# filter out small slopes and add them to neighbouring slopes
python glaciers.py cleanRast aspect_slopes aspect_clean $minarea

# make raw glacier units 
r.cross input=subbasins@subbasins,contours_clean,aspect_clean out=gunits_raw
# spatially explicit
r.clump input=gunits_raw output=gunits_clumped

### clean gunits and spatially explicit
# then clean each subbasin individually to fill each subbasin
python glaciers.py cleanGunits gunits_clumped subbasins@subbasins gunits_clean $minarea

# remove small overspilled units at glacierarea fringes and reduce glacierarea accordingingly
r.mask garea
python glaciers.py cleanRast gunits_clean gunits_cleaner $minarea 0
r.mapcalc exp='garea=if(!isnull(gunits_cleaner),1,null())' --o
r.mask garea --o
# clump again to renumber (enhancing performance, would also work without)
r.clump -d input=gunits_cleaner output=gunits

# routing
python glaciers.py routing gunits accumulation@subbasins nextID
# double check
python glaciers.py checkRouting nextID gunits routing_ratio
# routing ratio stats
# mean        1.653995
# std         1.387369
# min         0.102791
# 25%         0.839559
# 50%         1.225610
# 75%         2.005374
# max        20.711409


# make glacier units part of hydrotope map and include contours outside of glacier area
r.mask raster=subbasins@subbasins --o
r.mapcalc exp='gcontours=if(isnull(gunits),int(aster_iclean@DEM/200),gunits)'

# get valley/slope glacier units
r.statistics base=gunits cover=valleys method=mode output=gunits_valleys
r.mapcalc exp='gunits_valleys=int(@gunits_valleys)' --o


# hydrotope addresses
python glaciers.py hydAddressRast hydrotopes@hydrotopes subbasins@subbasins hydAddress

# calculate sun hours on June 21 and Dec 21
r.sun elevation=aster_iclean@DEM day=172 insol_time=sun_hr_doy172
r.sun elevation=aster_iclean@DEM day=355 insol_time=sun_hr_doy355



# write glacier str file (with 0 glacier height, 0 debris cover (cant have the same null0 name))
r.mask --o garea
python glaciers.py writeStr ~/wortmann/Alps/proSWIM/Input/glaciers.str gunits \
                    subbasins@subbasins hydAddress nextID gla0 slope_dg \
                    sun_hr_doy172 sun_hr_doy355 debris0

### SUBBASINS
g.mapset subbasins

# smooth out big glacier tongues to avoid splitting them
r.mapcalc exp='aster_mod=aster_iclean@DEM - 10*sqrt(tongues_dist@glaciers)'

# make subbasins with modified aster DEM
m.swim.subbasins elevation=aster_mod stations=stations  \
                 upthreshcolumn=subbasinthresh lothresh=2 streamthresh=30

-----------------------------------------------------------------
Catchment sizes :
ID  excl. upstream   incl. upstream  outlet subbasin  upstream stations               moved by/to
  1         872.19          5375.60                1  [ 2  3  4  5  6  7  8  9 10 11] 892.0m (558525.0, 133485.0)
  2         133.24           133.24               49  []                              351.2m (564221.8305692113, 129581.83056921125)
  3        2164.28          3768.74               70  [ 4  5  6  7  8  9 10]           61.2m (573108.1612508072, 108348.16125080718)
  4          39.34            39.34               36  []                               34.9m (670831.4079588715, 157171.40795887145)
  5         192.32           192.32               24  []                               30.5m (643695.0, 137325.0)
  6          78.51            78.51               48  []                              153.1m (642113.401164551, 129516.598835449)
  7         743.25           743.25               56  []                               50.5m (633558.6653143713, 120288.6653143714)
  8          31.32            31.32               80  []                               13.2m (619725.0, 114422.17975837238)
  9         171.43           171.43               58  []                               80.2m (611775.0, 114975.0)
 10         348.29           348.29               64  []                                9.0m (598365.0, 114646.10784053302)
 11         601.43           601.43              105  []                                5.0m (577854.8761423677, 103085.12385763226)

Subbasin statistics (km2):
Station:    total        1        2        3        4        5        6        7        8        9       10       11 
  Count:      158       19        5       42        1        8        3       40        1        4       10       25 
    Min:     2.11     2.24    11.58     2.96    39.34     2.82    18.23     4.26    31.32    20.12    12.03     2.11 
   Mean:    34.02    45.92    26.65    51.51    39.34    24.04    26.81    18.57    31.32    42.83    34.77    24.04 
    Max:   167.08   150.41    46.93   167.08    39.34    45.02    36.20    64.42    31.32    61.27   106.07    80.44 
-----------------------------------------------------------------


### SOILS
g.mapset soil

# get valley soils for each gunit
r.statistics base=gunits@glaciers cover=HWSD@soil method=mode output=gunits_soils
r.mapcalc exp='gunits_soils=int(@gunits_soils)' --o
# HWSD outside of glacier area, in valleys take gunits distributed HWSD, on slopes take special (decide later)
r.mapcalc exp='soils_HWSD=if(isnull(gunits_valleys@glaciers),HWSD@soil,if(gunits_valleys@glaciers,gunits_soils,null()))'

cd ../Methods/Soils/HWSD/HWSD2SWIMmodule_Vetter_update
r.stats soils_HWSD -n > mappingunits.dat

export PATH=$PATH:/iplex/01/best/Vetter.Tobias/Rcode/R-3.1.0/bin 
R -f hydroprops.R
R -f writefiles.R

# non-soils
echo "7003=17
7004=7
7005=17" >> output/swim_reclassification.dat

r.reclass input=soils_HWSD out=soils_SWIM rules=output/swim_reclassification.dat
# fill glacier area slopes and make real raster
r.mapcalc exp='soils_SWIM=if(isnull(soils_SWIM),18,soils_SWIM)' --o

mkdir /home/wortmann/wortmann/Alps/proSWIM/Input/Soil
cp output/soilfiles/* /home/wortmann/wortmann/Alps/proSWIM/Input/Soil

# dominant soil types
# 18 61.14% Lithic Leptosols (slopes, shallow)
# 17 11.92% Lithic Leptosols (valleys, deeper)
#  8  5.33% Haplic Podzols (1m deep)
#  9  5.17% Dystric Podzoluvisols (1m deep)
#  6  4.88% Calcaric Phaeozems (1m deep)
#  7  3.44% Calcaric Fluvisols (1m deep)
# 10  2.80% Calcic Gleysols
#  4  1.65%
#  5  1.51%
#  3  1.34%

### LANDUSE
g.mapset landuse

# distribute landuse over glacier units and rest leave as it is
r.statistics base=gunits@glaciers cover=GLC_EUv2@landuse method=mode output=gunits_landuse
r.mapcalc exp='GLC_gunits=if(!isnull(garea@glaciers),int(@gunits_landuse),GLC_EUv2@landuse)'

# reclass to SWIM
echo "2=11
4=10
6=10
13=14
14=14
16=1
18=14
20=1
21=15
22=2" > GLC_SWIM.reclass
r.reclass in=GLC_gunits out=landuse rules=GLC_SWIM.reclass
r.mapcalc exp='landuse=landuse' --o

### HYDROTOPES
g.mapset hydrotopes

m.swim.hydrotopes subbasins=subbasins@subbasins landuse=landuse@landuse \
                    soil=soils_SWIM@soil -c contourrast=gcontours elevation=aster_iclean@DEM \
                    hydrotopes=hydrotopes strfilepath=proSWIM/Input/rhone.str


# add 0 column for wetlands and irrigation
cd proSWIM/Input
python -c "import numpy as np
str=np.loadtxt('rhone.str')
np.savetxt('rhone.str',np.column_stack((str[:,:3],np.zeros(len(str)),str[:,3],np.zeros(len(str)),str[:,4:])),fmt='%14i')"

# strange 0 hydrotope to be pasted into str file
1      1       3      0     380    0    11029     9926100

### ROUTING
g.mapset -c routing

# copy subbasins
g.copy vect=subbasins@subbasins,subbasins


m.swim.routing subbasins=subbasins accumulation=accumulation@subbasins \
                figpath=proSWIM/Input/rhone.fig

### SUBBASIN STATS
g.mapset subbasins
m.swim.substats projectname=rhone projectpath=proSWIM subbasins=subbasins@subbasins \
                mainstreams=mainstreams@routing elevation=aster_iclean@DEM


### CLIMATE
g.mapset climate

# interpolate station elevation as reference elevation
v.surf.idw -n input=Oesterle_climate_reference_stations column=ALT \
                output=Oesterle_ALT_IDW npoints=10 power=1.0
g.mapset subbasins
v.db.addcolumn map=subbasins columns='Oesterle_elev int'
v.what.rast map=subbasins rast=Oesterle_ALT_IDW@climate column=Oesterle_elev type=centroid
g.mapset climate

# Oesterle stations only
m.swim.climate subbasins=subbasins@subbasins elevation=Oesterle_elev \
                climstations=Oesterle_climate_reference_stations \
                stationelevation=ALT fnames=ID ext=basz.dat \
                datadir=/home/wortmann/wortmann/Alps/DATA/Oesterle_data \
                outdir=/home/wortmann/wortmann/Alps/Climate/Oesterle_only_meanTLR/ \
                start=01.01.1905 end=31.12.2010 minnb=1 maxnb=10 maxdist=50 nodata=-999.9 method=IDW 

# reformat/bring to sealevel temp
cd /home/wortmann/wortmann/Alps/Climate/Oesterle_only
mv stationfile.dat stationfile_RAW.dat

# send for processing
llsubmit lljob.jcf

# bring to subbasin elevation
python TP_correction.py temp2reference 1970

### climate with all additional MeteoSwiss stations
v.extract meteoswiss_stations where="ID in ('AST', 'BEX', 'BIN', 'BLA', 'BRI', 'BSP', 'CDM', 'CTA', 'DIB', 'EVL', 'EVO', 'FEY', 'FIO', 'FIT', 'GRI', 'GRY', 'HER', 'LEU', 'MAB', 'MAR', 'MAU', 'MGI', 'MOB', 'MTE', 'OBW', 'ORS', 'PSB', 'RIE', 'SAF', 'SBA', 'SRE')" out=meteoswiss_additional

# interpolate station elevation as reference elevation
v.patch in=Oesterle_climate_reference_stations,meteoswiss_additional out=ref_add_stations
 
v.surf.idw -n input=ref_add_stations output=ref_add_ALT_IDW npoints=10 power=1.0
v.surf.bspline ref_add_stations raster_output=ref_add_ALT_bspline ns_step=1000 ew_step=1000

g.mapset subbasins
v.db.addcolumn map=subbasins columns='ref_add_elev int'
v.what.rast map=subbasins rast=ref_add_ALT_IDW@climate column=ref_add_elev type=centroid
g.mapset climate

# additional stations only
m.swim.climate subbasins=subbasins@subbasins elevation=ref_add_elev \
                climstations=meteoswiss_additional \
                stationelevation=elevation fnames=ID ext=.dat \
                datadir=/home/wortmann/wortmann/Alps/DATA/MeteoSwiss/STARS_formatted \
                outdir=/home/wortmann/wortmann/Alps/Climate/ref_add_climate/ \
                start=01.01.1905 end=31.12.2010 minnb=1 maxnb=10 maxdist=50 nodata=-999.9 method=IDW
# add ref stations
cd Climate/ref_add_climate
mv stationfile.dat stationfile_add.dat

m.swim.climate subbasins=subbasins@subbasins elevation=Oesterle_elev \
                climstations=Oesterle_climate_reference_stations \
                stationelevation=ALT fnames=ID ext=basz.dat \
                datadir=/home/wortmann/wortmann/Alps/DATA/Oesterle_data \
                outdir=/home/wortmann/wortmann/Alps/Climate/ref_add_climate/ \
                start=01.01.1905 end=31.12.2010 minnb=1 maxnb=10 maxdist=50 nodata=-999.9 method=IDW

tail -n+2 stationfile_add.dat >> stationfile.dat
mv stationfile.dat stationfile_RAW.dat
# !!! make sure stationfile has a continuous ID column!!!

# reformat/bring to sealevel temp, will rewrite stationfile.dat
python TP_correction.py temp2sealevel

# send for processing
llsubmit lljob.jcf

# bring to subbasin elevation
python TP_correction.py temp2reference 1905

### MISC. FILES

# make wstor.dat
g.mapset subbasins
v.db.addcolumn map=subbasins columns='nills int'
v.db.update map=subbasins column=nills value=0
# write to file sorted by subbasinID
python -c "import grass.script as grass
tbl=grass.vector_db_select('subbasins',columns='subbasinID,nills,Oesterle_elev')
for l in sorted(tbl['values'].keys()): print '%4i %3i %5i' %tuple(map(int,tbl['values'][l]))
" > proSWIM/Input/wstor.dat

# runoff.dat
python -c "import pandas as pa; import numpy as np
q=pa.read_pickle('DATA/GRDC_discharge/GRDC_stations.pa')
q=q.truncate(before='1905-01-01',after='2010-12-31')
q['y'],q['m'],q['d'] = q.index.year,q.index.month,q.index.day
np.savetxt('proSWIM/Input/runoff.dat',q[['y','m','d','6939200']],fmt='%4i'*3+'%7.1f')"


# subcatch def
v.db.join map=subbasins@subbasins column=catchmentID otable=stations_stations ocolumn=cat scolumns=stationID
python -c "import grass.script as grass
tbl=grass.vector_db_select('subbasins',columns='subbasinID,catchmentID,stationID')
print 'subbasinID  subcatchID  stationID'
for l in sorted(tbl['values'].keys()): print '%s %s %s' %tuple(tbl['values'][l])
" > proSWIM/Input/subcatch.def

